# 基础算法

## 链表与数组

### 性能对比

| 时间复杂度 | 数组 | 链表 |

| —— | —— | —— |

| 插入删除 |  O(n) | O(1) |

| 随机访问 | O(1) | O(n) |

###  基于链表实现LRU算法

* 维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。
* 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后在插入到链表的头部。
* 如果此数据没有在缓存链表中，如果此时缓存未满，则将此结点直接插入到链表头部，如果此时缓存已满，则链表尾结点删除，将新的数据节点插入链表的头部。
* 缓存访问的时间复杂度O(n)。
* 优化：引入散列表来记录每个数据的位置，将缓存访问的时间复杂度降到O(1)。

## 排序

### 冒泡排序

* 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，最多重复n次，完成排序。
* 时间复杂度：最好 O(n)  最坏 O(n^2)  平均 O(n^2) 
* 是否稳定： 是

### 插入排序

* 首先，将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组第一个元素。插入算法的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。
* 时间复杂度：最好 O(n)  最坏 O(n^2)  平均 O(n^2) 
* 是否稳定： 是

### 选择排序

* 选择排序也分已排序区间和未排序区间，但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。
* 时间复杂度：最好 O(n^2)  最坏 O(n^2)  平均 O(n^2) 
* 是否稳定： 否

### 归并排序

* 先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起。
* 时间复杂度： O(nlogn)  空间复杂度： O(n)   是否稳定： 是

### 快速排序

* 如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot (分区点)。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。然后用递归排序下标从 p 到 pivot下标-1 之间的数据和小标从 pivot下标+1 到 r 之间的数据，直到区间缩小为1。
* 时间复杂度： O(nlogn)  空间复杂度： O(1)  是否稳定： 否

## 二叉树

### 遍历

* 前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
* 中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
* 后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印本身。
* 时间复杂度： 都是O(n)

### 二叉查找树

* 二叉查找树要求，在树的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。
* 中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度O(n)
* 时间复杂度：平衡二叉查找树插入、删除、查找操作都是 O(logn)
* AVL树是平衡二叉查找树

### 红黑树

* 红黑树中的节点，一类被标记为黑色，一类被标记为红色。红黑树满足以下要求。
* 1. 根节点是黑色的
  2. 每个叶子节点都是黑色的空节点，也就是说，叶子节点不存储数据。
  3. 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的。
  4. 每个节点，从该节点到达可达叶子节点的所有路径，都包含相同数目的黑色节点。
* 红黑树是近似平衡的。平衡的意思可以等价为性能不退化，近似平衡就等价为性能不会退化的太严重。
* 时间复杂度：插入、删除、查找操作都是 O(logn)

## 堆

* 堆是一个完全二叉树，堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值。

- 时间复杂度： 插入、删除都是 O(logn)

### 堆排序

* 堆排序包括建堆和排序两个操作
* 建堆的过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是O(nlogn)

### 堆排序 vs 快排

* 堆排序数据访问的方式没有快排友好。快排数据是顺序访问，堆排序数据是跳着访问，对CPU缓存不友好。
* 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快排