## 软件体系结构（1.3站得高，望得远 P8）

* 系统软件体系结构：
![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/system_soft_architecture.png)
* 每个层次之间都需要互相通信，既然要通信就必须有一个通信的协议，我们一般将其称为接口(Interface)，接口的下面那层是接口的提供者，由他定义接口；接口的上面那层是接口的使用者。层次体系中，接口是被精心设计过的，尽量保持稳定不变，那么理论上层次之间只需要遵循这个接口，任何一个层都可以被修改或被替换。除了硬件和应用程序，其他都是所谓的中间层，每个中间层都是对它下面的那层的包装和扩展。最近流行的虚拟机技术更是在硬件和操作系统之间增加了一层虚拟层，使得一个计算机上可以同时运行多个操作系统，这个也是层次结构带来的好处，在尽可能少改变甚至不改变其他层的情况下，新增一个层次就可以提供前所未有的功能。


* 我们的软件体系中，最上层的是应用程序，比如我们平时用到的网络浏览器、Email客户端、多媒体播放器、图片浏览器等。从整个层次结构上来看，开发工具与应用程序是属于同一个层次的，因为它们都是用一个接口，那就是操作系统应用程序编程接口(Application Programming Interface)。应用程序接口的提供者是运行库，什么样的运行库提供什么样的API。
* 运行时库使用操作系统提供的系统调用接口(System call Interface)，系统调用接口在实现中往往是以软件中断(Software Interrupt)的方式提供
* 操作系统内核层对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者，硬件的接口定义决定了操作系统内核，具体来讲就是驱动程序如何操作硬件，如何与硬件进行通信。这种接口叫做硬件规格(Hardware Specification)

### 操作系统（1.4 操作系统做什么 P10）

* 操作系统的一个功能是提供抽象的接口，另一个主要功能是管理硬件资源
* 多任务(multi-tasking)系统：目前几乎所有现代的操作系统都是采用这种方式。操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别。所有的应用程序都以进程的方式运行在比操作系统权限更低的级别，每个进程都有自己独立的地址空间，使得进程之间的地址相互隔离。CPU由操作系统统一进行分配，每个进程根据进程优先级的高低都有机会得到CPU，但是如果运行时间超出了一定的时间，操作系统会暂停该进程，将CPU资源分配给其他得等待运行的进程。这种CPU的分配方式即所谓的抢占式，操作系统可以强制剥夺CPU资源并分配给它认为目前最需要的进程。如果操作系统分配给每个进程的时间都很短，即CPU在多个进程间快速的切换，从而造成了很多进程都在同时运行的假象。

### 内存（1.5 内存不够怎么办 P15）

* 地址空间分两种：虚拟地址空间(Virtual Address Space)和物理地址空间(Pyhsical Address Space)。物理地址空间是实实在在存在的，存在于计算机中，而且对于每台计算机来说只有唯一一个，你可以把物理空间想象成物理内存，比如你的计算机用的Inter的Pentium 4的处理器，那么它是32位的机器，计算机地址线有32条(实际上36条)，那么物理空间就有4GB。但你的计算机只装了512MB的内存，那么其实物理地址的真正有效部分只有0x00000000~0x1FFFFFFF，其他部分都无效。虚拟地址空间是指虚拟的、人们想象出来的地址空间，它并不存在，每个进程都有自己独立的虚拟空间，而且每个进程只能访问自己的地址空间，这样就有效地做到了进程隔离。

* 内存分页(Paging)：分页的基本方法是把地址空间人为的等分成固定大小的页，每一页的大小由硬件决定，或硬件支持多种大小的页，由操作系统决定页的大小。比如Inter Pentium系列处理器支持4KB或者4MB的页大小，那么操作系统可以选择每页大小为4KB，也可以选择为4MB，但是在同一时刻只能选择一种大小。

  ![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/system_soft_cache_example.png)

  ![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/system_soft_cache1.png)

  ![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/system_soft_cache2.png)

### 线程 （1.6 众人拾柴火焰高 P19）

![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/system_soft_thread.png)

## 静态链接（P38）


* 从程序源代码到最终可执行文件的4个步骤：预处理（Prepressing）、编译（Compilation）、汇编（Assembly）、链接（Linking）。

* 源代码 -> 预处理 -> 预处理后文件 -> 编译器 -> 汇编代码 -> 汇编器 -> 目标文件

  ![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/code_to_exe.png)

* 预编译（预处理）：预编译过程主要处理那些源代码文件中的以“#”开始的预编译指令。比如“#include”、“#define”等，主要处理规则如下：
  * 将所有的“#define”删除，并且展开所有的宏定义
  * 处理所有条件预编译指令，比如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”
  * 处理“#include”预编译指令，将被包含的文件从插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。
  * 删除所有的注释 “//” 和 “/* */”
  * 添加行号和文件名标识，比如#2 “hello.c” 2，以便于编译时编译器产生调试用的行号信息以及用于编译时产生的编译错误或警告时能够显示行号。
  * 保留所有的#progma 编译器指令，因为编译器须要使用它们
* 编译：编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程是整个程序构建的核心部分，也是最复杂的部分
* 汇编：汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，没有复杂语法，没有语义，不需要做指令优化。

### 编译

* 编译过程一般可以分为6步：扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成、目标代码优化。

#### 编译器前端

* 扫描(词法分析)：首先源代码程序被输入到扫描器，扫描器的任务很简单，它只是简单的进行词法分析。词法分析产生的记号一般可以分为：关键字、标识符、字面量和特殊符号几类。在识别记号的同时，扫描器也完成了其他工作。比如将标识符存放到符号表，将数字、字符串常量存放到文字表等等，以备后面步骤使用。

* 语法分析：接下来语法分析器将对由扫描器产生的的记号进行语法分析，从而产生语法树。简单的讲，由语法分析器生成的语法树就是以表达式为节点的树。例如C语言的代码`array[index] = (index + 4) * (2 + 6)`的语法分析生成的语法树为下图所示。

  ![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/syntax_tree_demo.png)

* 语义分析：语法分析仅仅是完成了对表达式的语法层面的分析，但是它不了解这个语句是否有真正意义，比如两个指针做乘法运算是没有意义的。语义分析程序发现类型不匹配的时候，编译器会报错。编译器所能分析的语义是静态语义，静态语义是指在编译器可以确定的，对应的动态语义是只有在运行期才能确定的语义。

  ![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/syntax_tree_demo1.png)

* 中间语言生成（源代码优化）：源码级优化器会在源代码级别进行优化，例如(2+6)这个表达式可以被优化掉，因为它的值在编译期就可以被确定。类似的还有好多其他复杂的优化过程。

  ![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/syntax_tree_demo2.png)

  ![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/syntax_tree_demo3.png)

#### 编译器后端

* 目标代码生成与优化：

  ![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/syntax_tree_demo4.png)

#### 引出链接

![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/syntax_tree_demo5.png)

### 链接

* 一个复杂的软件，人们把每个源代码模块独立的编译，然后按照需要将它们组装起来，这个组装模块的过程就是链接。链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够争取的衔接。链接的主要过程包括地址和空间分配、符号决议（符号绑定）和重定位。
* 比如在程序模块main.c中使用另外一个模块func.c中的函数foo()。我们在main.c模块中每一处调用foo的时候都必须确切的知道foo这个函数的地址，但是由于每个模块都是单独编译的，编译main.c的时候并不知道foo函数的地址，所以暂时把调用foo的指令的目标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正（重定位）。
* 在链接中，我们将函数和变量统称为符号，函数名或变量名就是符号名。链接的过程很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表，这个表里记录了目标文件中所用到的所有符号。每个定义的符号有个对应的值，叫做符号值，对于变量和函数来说，符号值就是它们的地址。

### ABI

* 如果要使两个编译器编译出来的目标文件能够相互链接，那么这两个目标文件必须满足：采用同样的目标文件格式、拥有同样的符号修饰标准、变量的内存分布方式相同、函数的调用方式相同，等等。其中我们把符号修饰标准、变量内存布局、函数调用方式等这些跟可执行代码二进制兼容性相关的内容成为ABI。
* API和ABI都是所谓的应用程序接口，只是它们所描述的接口所在层面不一样。API往往是指源代码级别的接口，而ABI是指二进制层面的接口。
* 影响ABI的因素非常多，硬件、编程语言、编译器、链接器、操作系统等都会影响ABI。

### 静态链接

* 当我们有两个目标文件时，如何将它们链接起来形成一个可执行文件，这基本上就是链接的核心内容：静态链接。对于链接器来说，整个链接过程中，它就是将几个输入目标文件加工后合并成一个输出文件。
* 链接过程中，多个目标文件的相同性质的段会合并在一起，比如将所有输入文件的.text合并到输出文件的.text段，接着是.data段、.bss段等。
* 链接器为目标文件分配地址和空间，这里的“地址和空间”有两个含义：第一个是在输出的可执行文件中的空间，第二个是装载后的虚拟地址中的虚拟地址空间。比如.text和.data，它们在文件中虚拟地址中都要分配空间，因为它们在两者中都存在，对于.bss段来说，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。
* 整个静态链接过程分两步：
* 1.空间与地址分配：扫描所有的输入目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步中，链接器能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，建立映射关系。
* 2.符号解析与重定位：使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。重定位过程是链接的核心。
* 小结：目标文件再被链接成最终可执行文件时，输入目标文件中各个段被合并到输出文件中，链接器为它们分配在输出文件中的空间和地址。一旦输入段的最终地址被确定，接下来就可以进行符号的解析与重定位，链接器会把各个输入目标文件中对于外部符号的引用进行解析，把每个段中需重定位的指令和数据进行“修补”，使它们都指向正确的位置。

## 目标文件

* 编译器编译源代码后生成的文件叫做目标文件，目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程。

* 不光是可执行文件按照可执行文件格式存储，动态链接库及静态链接库文件都按照可执行文件格式存储。

* 目标文件的内容有编译后的机器指令代码、数据，还有链接时所需要的一些信息，例如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以“节”（Section）的形式存储，有时候也叫“段”（Segment），它们都标识一个一定长度的区域。

* 目标文件的基本结构图：

  |          基本结构图          |
  | :--------------------------: |
  |            Header            |
  |            .text             |
  |            .data             |
  |             .bss             |
  |          ... 其他段          |
  | 段表（Section header table） |
  |           字符串表           |
  |            符号表            |
  |             ...              |

* 文件头定义了魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、重定位类型、硬件平台、入口地址、段表的位置和长度、段的数量等。
* 代码段(.text)：目标文件中，源代码编译后的机器指令经常被放在代码段里
* 数据段(.data)：目标文件中，源代码编译后的全局变量和局部静态变量数据经常放在数据段
* .bss段：目标文件中，源代码编译后的未初始化的全局变量和局部静态变量一般放在.bss段里。.bss段在目标文件和可执行文件中不占用文件的空间，它在装载时占用地址空间。
* 只读数据段(.rodata)：只读数据段存放的是只读数据，一般是程序里面的只读变量和字符串常量。有时候编译器会把字符串常量放到数据段(.data)
* ... 其他段
* 段表：段表是目标文件中除了文件头意外最重要的结构，他描述了目标文件各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限以及段的其他属性。目标文件的段结构就是由段表决定的，编译器、链接器和装载器都是依靠段表来定位和访问各个段的属性的。
* 字符串表：目标文件中用到了很多字符串，比如段名、变量名等，因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后用字符串在表中的偏移来引用字符串。
* 符号表：符号表的结构很简单，它是一个Elf32_Sym结构的数组，每个结构对应一个符号。
* 总体来说，程序源代码被编译以后主要分成两种段：程序指令与程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据。对于进程来说，指令区域是只读的，数据区域是可读写的。

## 装载

* 可执行文件只有装载到内存以后才能被CPU执行。程序执行时所需要的指令和数据必须在内存中才能够正常运行。

* 创建一个进程，装载相应的可执行文件并且执行。在有虚拟存储的情况下，要做三件事：

  1.创建一个独立的虚拟地址空间。

  2.读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。

  3.将CPU的执行寄存器设置成可执行文件的入口地址，启动运行。

* 上面的步骤执行完之后，可执行文件的真正指令和数据都没有被装入到内存中。假设程序的入口地址为0x08048000，当CPU开始打算执行这个地址的指令时，发现页面0x08048000~0x08049000是个空页面，于是它认为这是个`页错误`,CPU将控制权交给操作系统，操作系统有专门的页错误处理例程来处理。这时候上面第二步建立起来的数据结构起了关键作用，操作系统查询这个数据结构，找到空页面所在的VMA（虚拟内存区域），计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中虚拟页与分配的物理页之间建立映射关系，然后把控制权再还给进程，进程从刚才页错误的位置重新开始执行。随着进程的执行，页错误也会不断地产生，操作系统也会为进程分配相应的物理页来满足进程执行的需求。

* 可执行文件中，段的权限往往下面三种：

  1.以代码段为代表的的权限为可读可执行的段

  2.以数据段和BSS段为代表的权限为可读可写的段。

  3.以只读数据段为代表的权限为只读的段

* 对于相同权限的段，把它们合并到一起当做一个段进行映射。合并起来的段一个段映射一个页（如果段的大小没有超过一页大小）。合并在一起的段（Section）叫做一个Segment

* 在操作系统里，VMA除了被用来映射可执行文件中的各个Segment外，操作系统通过使用VMA来对进程的地址空间进行管理。进程在执行的时候还需要用到栈、堆等空间，它们在进程的虚拟空间中的表现也是以VMA形式存在的。

* 进程中虚拟地址空间：操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间。基本原则是将相同权限属性的、有相同映像文件的映射而成一个VMA。一个进程基本上可以分为如下几种VMA区域：

  1. 代码VMA，权限只读、可执行；有映像文件。
  2. 数据VMA，权限可读写 、可执行；有映像文件。
  3. 堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展
  4. 栈VMA，权限可读写、不可执行；无映像文件，匿名，可向下扩展

  > 由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件。

![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/load_VMA.png)

