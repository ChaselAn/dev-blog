## 软件体系结构（1.3站得高，望得远 P8）

* 系统软件体系结构：
![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/system_soft_ architecture.png)
* 每个层次之间都需要互相通信，既然要通信就必须有一个通信的协议，我们一般将其称为接口(Interface)，接口的下面那层是接口的提供者，由他定义接口；接口的上面那层是接口的使用者。层次体系中，接口是被精心设计过的，尽量保持稳定不变，那么理论上层次之间只需要遵循这个接口，任何一个层都可以被修改或被替换。除了硬件和应用程序，其他都是所谓的中间层，每个中间层都是对它下面的那层的包装和扩展。最近流行的虚拟机技术更是在硬件和操作系统之间增加了一层虚拟层，使得一个计算机上可以同时运行多个操作系统，这个也是层次结构带来的好处，在尽可能少改变甚至不改变其他层的情况下，新增一个层次就可以提供前所未有的功能。


* 我们的软件体系中，最上层的是应用程序，比如我们平时用到的网络浏览器、Email客户端、多媒体播放器、图片浏览器等。从整个层次结构上来看，开发工具与应用程序是属于同一个层次的，因为它们都是用一个接口，那就是操作系统应用程序编程接口(Application Programming Interface)。应用程序接口的提供者是运行库，什么样的运行库提供什么样的API。

* 运行时库使用操作系统提供的系统调用接口(System call Interface)，系统调用接口在实现中往往是以软件中断(Software Interrupt)的方式提供

* 操作系统内核层对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者，硬件的接口定义决定了操作系统内核，具体来讲就是驱动程序如何操作硬件，如何与硬件进行通信。这种接口叫做硬件规格(Hardware Specification)

* 从程序源代码到最终可执行文件的4个步骤：预处理（Prepressing）、编译（Compilation）、汇编（Assembly）、链接（Linking）。

  ![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/code_to_exe.png)

## 预编译（预处理）

​	预编译过程主要处理那些源代码文件中的以“#”开始的预编译指令。比如“#include”、“#define”等，主要处理规则如下：

* 将所有的“#define”删除，并且展开所有的宏定义

* 处理所有条件预编译指令，比如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”

* 处理“#include”预编译指令，将被包含的文件从插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。

* 删除所有的注释 “//” 和 “/* */”

* 添加行号和文件名标识，比如#2 “hello.c” 2，以便于编译时编译器产生调试用的行号信息以及用于编译时产生的编译错误或警告时能够显示行号。

* 保留所有的#progma 编译器指令，因为编译器须要使用它们

## 编译

编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程是整个程序构建的核心部分，也是最复杂的部分

* 编译过程一般可以分为6步：扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成、目标代码优化。

* 扫描：首先源代码程序被输入到扫描器，扫描器的任务很简单，它只是简单的进行词法分析。词法分析产生的记号一般可以分为：关键字、标识符、字面量和特殊符号几类。在识别记号的同时，扫描器也完成了其他工作。比如将标识符存放到符号表，将数字、字符串常量存放到文字表等等，以备后面步骤使用。

* 语法分析：接下来语法分析器将对由扫描器产生的的记号进行语法分析，从而产生语法树。简单的讲，由语法分析器生成的语法树就是以表达式为节点的树。例如C语言的代码`array[index] = (index + 4) * (2 + 6)`的语法分析生成的语法树为下图所示。

  ![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/syntax_tree_demo.png)

* 语义分析：语法分析仅仅是完成了对表达式的语法层面的分析，但是它不了解这个语句是否有真正意义，比如两个指针做乘法运算是没有意义的。语义分析程序发现类型不匹配的时候，编译器会报错。编译器所能分析的语义是静态语义，静态语义是指在编译器可以确定的，对应的动态语义是只有在运行期才能确定的语义。

* 中间语言生成（源代码优化）：源码级优化器会在源代码级别进行优化，例如(2+6)这个表达式可以被优化掉，因为它的值在编译期就可以被确定。类似的还有好多其他复杂的优化过程。优化器直接在语法树上做优化比较困难，所以源代码优化器往往将整个语法树转换成中间代码，他是语法树的顺序表示，其实它非常接近目标代码，但是它跟目标机器和运行时环境无关，比如它不包含数据的尺寸、变量地址、寄存器名字。

* 中间代码使得编译器可以被分为前端和后端。编译期前端负责产生机器无关的中间代码，编译期后端将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译期而言，可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。

* 目标代码生成与优化：代码生成器将中间代码转换成目标机器代码，这个过程依赖于目标机器，因为不同的机器有着不同的字长、寄存器、数据类型等。目标代码优化器会对目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。

* 定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代的编译期可以将一个源代码文件编译成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。

## 链接

* 一个复杂的软件，人们把每个源代码模块独立的编译，然后按照需要将它们组装起来，这个组装模块的过程就是链接。链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够争取的衔接。链接的主要过程包括地址和空间分配、符号决议（符号绑定）和重定位。
* 比如在程序模块main.c中使用另外一个模块func.c中的函数foo()。我们在main.c模块中每一处调用foo的时候都必须确切的知道foo这个函数的地址，但是由于每个模块都是单独编译的，编译main.c的时候并不知道foo函数的地址，所以暂时把调用foo的指令的目标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正（重定位）。
* 在链接中，我们将函数和变量统称为符号，函数名或变量名就是符号名。链接的过程很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表，这个表里记录了目标文件中所用到的所有符号。每个定义的符号有个对应的值，叫做符号值，对于变量和函数来说，符号值就是它们的地址。

### ABI

* 如果要使两个编译器编译出来的目标文件能够相互链接，那么这两个目标文件必须满足：采用同样的目标文件格式、拥有同样的符号修饰标准、变量的内存分布方式相同、函数的调用方式相同，等等。其中我们把符号修饰标准、变量内存布局、函数调用方式等这些跟可执行代码二进制兼容性相关的内容成为ABI。
* API和ABI都是所谓的应用程序接口，只是它们所描述的接口所在层面不一样。API往往是指源代码级别的接口，而ABI是指二进制层面的接口。
* 影响ABI的因素非常多，硬件、编程语言、编译器、链接器、操作系统等都会影响ABI。

### 静态链接

* 当我们有两个目标文件时，如何将它们链接起来形成一个可执行文件，这基本上就是链接的核心内容：静态链接。对于链接器来说，整个链接过程中，它就是将几个输入目标文件加工后合并成一个输出文件。
* 链接过程中，多个目标文件的相同性质的段会合并在一起，比如将所有输入文件的.text合并到输出文件的.text段，接着是.data段、.bss段等。
* 链接器为目标文件分配地址和空间，这里的“地址和空间”有两个含义：第一个是在输出的可执行文件中的空间，第二个是装载后的虚拟地址中的虚拟地址空间。比如.text和.data，它们在文件中虚拟地址中都要分配空间，因为它们在两者中都存在，对于.bss段来说，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。
* 整个静态链接过程分两步：
* 1.空间与地址分配：扫描所有的输入目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步中，链接器能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，建立映射关系。
* 2.符号解析与重定位：使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。重定位过程是链接的核心。
* 小结：目标文件再被链接成最终可执行文件时，输入目标文件中各个段被合并到输出文件中，链接器为它们分配在输出文件中的空间和地址。一旦输入段的最终地址被确定，接下来就可以进行符号的解析与重定位，链接器会把各个输入目标文件中对于外部符号的引用进行解析，把每个段中需重定位的指令和数据进行“修补”，使它们都指向正确的位置。

## 目标文件

* 编译器编译源代码后生成的文件叫做目标文件，目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程。

* 不光是可执行文件按照可执行文件格式存储，动态链接库及静态链接库文件都按照可执行文件格式存储。

* 目标文件的内容有编译后的机器指令代码、数据，还有链接时所需要的一些信息，例如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以“节”（Section）的形式存储，有时候也叫“段”（Segment），它们都标识一个一定长度的区域。

* 目标文件的基本结构图：

  |          基本结构图          |
  | :--------------------------: |
  |            Header            |
  |            .text             |
  |            .data             |
  |             .bss             |
  |          ... 其他段          |
  | 段表（Section header table） |
  |           字符串表           |
  |            符号表            |
  |             ...              |

* 文件头定义了魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、重定位类型、硬件平台、入口地址、段表的位置和长度、段的数量等。
* 代码段(.text)：目标文件中，源代码编译后的机器指令经常被放在代码段里
* 数据段(.data)：目标文件中，源代码编译后的全局变量和局部静态变量数据经常放在数据段
* .bss段：目标文件中，源代码编译后的未初始化的全局变量和局部静态变量一般放在.bss段里。.bss段在目标文件和可执行文件中不占用文件的空间，它在装载时占用地址空间。
* 只读数据段(.rodata)：只读数据段存放的是只读数据，一般是程序里面的只读变量和字符串常量。有时候编译器会把字符串常量放到数据段(.data)
* ... 其他段
* 段表：段表是目标文件中除了文件头意外最重要的结构，他描述了目标文件各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限以及段的其他属性。目标文件的段结构就是由段表决定的，编译器、链接器和装载器都是依靠段表来定位和访问各个段的属性的。
* 字符串表：目标文件中用到了很多字符串，比如段名、变量名等，因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后用字符串在表中的偏移来引用字符串。
* 符号表：符号表的结构很简单，它是一个Elf32_Sym结构的数组，每个结构对应一个符号。
* 总体来说，程序源代码被编译以后主要分成两种段：程序指令与程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据。对于进程来说，指令区域是只读的，数据区域是可读写的。

## 汇编

汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。

## 装载

* 可执行文件只有装载到内存以后才能被CPU执行。程序执行时所需要的指令和数据必须在内存中才能够正常运行。

* 创建一个进程，装载相应的可执行文件并且执行。在有虚拟存储的情况下，要做三件事：

  1.创建一个独立的虚拟地址空间。

  2.读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。

  3.将CPU的执行寄存器设置成可执行文件的入口地址，启动运行。

* 上面的步骤执行完之后，可执行文件的真正指令和数据都没有被装入到内存中。假设程序的入口地址为0x08048000，当CPU开始打算执行这个地址的指令时，发现页面0x08048000~0x08049000是个空页面，于是它认为这是个`页错误`,CPU将控制权交给操作系统，操作系统有专门的页错误处理例程来处理。这时候上面第二步建立起来的数据结构起了关键作用，操作系统查询这个数据结构，找到空页面所在的VMA（虚拟内存区域），计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中虚拟页与分配的物理页之间建立映射关系，然后把控制权再还给进程，进程从刚才页错误的位置重新开始执行。随着进程的执行，页错误也会不断地产生，操作系统也会为进程分配相应的物理页来满足进程执行的需求。

* 可执行文件中，段的权限往往下面三种：

  1.以代码段为代表的的权限为可读可执行的段

  2.以数据段和BSS段为代表的权限为可读可写的段。

  3.以只读数据段为代表的权限为只读的段

* 对于相同权限的段，把它们合并到一起当做一个段进行映射。合并起来的段一个段映射一个页（如果段的大小没有超过一页大小）。合并在一起的段（Section）叫做一个Segment

* 在操作系统里，VMA除了被用来映射可执行文件中的各个Segment外，操作系统通过使用VMA来对进程的地址空间进行管理。进程在执行的时候还需要用到栈、堆等空间，它们在进程的虚拟空间中的表现也是以VMA形式存在的。

* 进程中虚拟地址空间：操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间。基本原则是将相同权限属性的、有相同映像文件的映射而成一个VMA。一个进程基本上可以分为如下几种VMA区域：

  1. 代码VMA，权限只读、可执行；有映像文件。
  2. 数据VMA，权限可读写 、可执行；有映像文件。
  3. 堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展
  4. 栈VMA，权限可读写、不可执行；无映像文件，匿名，可向下扩展

  > 由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件。

![](https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/load_VMA.png)

