* 我们的软件体系中，最上层的是应用程序，比如我们平时用到的网络浏览器、Email客户端、多媒体播放器、图片浏览器等。从整个层次结构上来看，开发工具与应用程序是属于同一个层次的，因为它们都是用一个接口，那就是操作系统应用程序编程接口(Application Programming Interface)。应用程序接口的提供者是运行库，什么样的运行库提供什么样的API。

* 从程序源代码到最终可执行文件的4个步骤：预处理（Prepressing）、编译（Compilation）、汇编（Assembly）、链接（Linking）。

  ![https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/code_to_exe.png)

## 预编译（预处理）

​	预编译过程主要处理那些源代码文件中的以“#”开始的预编译指令。比如“#include”、“#define”等，主要处理规则如下：

* 将所有的“#define”删除，并且展开所有的宏定义

* 处理所有条件预编译指令，比如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”

* 处理“#include”预编译指令，将被包含的文件从插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。

* 删除所有的注释 “//” 和 “/* */”

* 添加行号和文件名标识，比如#2 “hello.c” 2，以便于编译时编译器产生调试用的行号信息以及用于编译时产生的编译错误或警告时能够显示行号。

* 保留所有的#progma 编译器指令，因为编译器须要使用它们

## 编译

编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程是整个程序构建的核心部分，也是最复杂的部分

* 编译过程一般可以分为6步：扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成、目标代码优化。

* 扫描：首先源代码程序被输入到扫描器，扫描器的任务很简单，它只是简单的进行词法分析。词法分析产生的记号一般可以分为：关键字、标识符、字面量和特殊符号几类。在识别记号的同时，扫描器也完成了其他工作。比如将标识符存放到符号表，将数字、字符串常量存放到文字表等等，以备后面步骤使用。

* 语法分析：接下来语法分析器将对由扫描器产生的的记号进行语法分析，从而产生语法树。简单的讲，由语法分析器生成的语法树就是以表达式为节点的树。例如C语言的代码`array[index] = (index + 4) * (2 + 6)`的语法分析生成的语法树为下图所示。

  ![https://raw.githubusercontent.com/ChaselAn/dev-blog/master/Source/Notes/ziwoxiuyang/syntax_tree_demo.png)

* 语义分析：语法分析仅仅是完成了对表达式的语法层面的分析，但是它不了解这个语句是否有真正意义，比如两个指针做乘法运算是没有意义的。语义分析程序发现类型不匹配的时候，编译器会报错。编译器所能分析的语义是静态语义，静态语义是指在编译器可以确定的，对应的动态语义是只有在运行期才能确定的语义。

* 中间语言生成（源代码优化）：源码级优化器会在源代码级别进行优化，例如(2+6)这个表达式可以被优化掉，因为它的值在编译期就可以被确定。类似的还有好多其他复杂的优化过程。优化器直接在语法树上做优化比较困难，所以源代码优化器往往将整个语法树转换成中间代码，他是语法树的顺序表示，其实它非常接近目标代码，但是它跟目标机器和运行时环境无关，比如它不包含数据的尺寸、变量地址、寄存器名字。

* 中间代码使得编译器可以被分为前端和后端。编译期前端负责产生机器无关的中间代码，编译期后端将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译期而言，可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。

* 目标代码生成与优化：代码生成器将中间代码转换成目标机器代码，这个过程依赖于目标机器，因为不同的机器有着不同的字长、寄存器、数据类型等。目标代码优化器会对目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。

* 定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代的编译期可以将一个源代码文件编译成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。

## 链接

* 一个复杂的软件，人们把每个源代码模块独立的编译，然后按照需要将它们组装起来，这个组装模块的过程就是链接。链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够争取的衔接。链接的主要过程包括地址和空间分配、符号决议（符号绑定）和重定位。
* 比如在程序模块main.c中使用另外一个模块func.c中的函数foo()。我们在main.c模块中每一处调用foo的时候都必须确切的知道foo这个函数的地址，但是由于每个模块都是单独编译的，编译main.c的时候并不知道foo函数的地址，所以暂时把调用foo的指令的目标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正（重定位）。
* 在链接中，我们将函数和变量统称为符号，函数名或变量名就是符号名。链接的过程很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表，这个表里记录了目标文件中所用到的所有符号。每个定义的符号有个对应的值，叫做符号值，对于变量和函数来说，符号值就是它们的地址。

## 目标文件

* 编译器编译源代码后生成的文件叫做目标文件，目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程。

* 不光是可执行文件按照可执行文件格式存储，动态链接库及静态链接库文件都按照可执行文件格式存储。

* 目标文件的内容有编译后的机器指令代码、数据，还有链接时所需要的一些信息，例如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以“节”（Section）的形式存储，有时候也叫“段”（Segment），它们都标识一个一定长度的区域。

* 目标文件的基本结构图：

  |          基本结构图          |
  | :--------------------------: |
  |            Header            |
  |            .text             |
  |            .data             |
  |             .bss             |
  |          ... 其他段          |
  | 段表（Section header table） |
  |           字符串表           |
  |            符号表            |
  |             ...              |

* 文件头定义了魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、重定位类型、硬件平台、入口地址、段表的位置和长度、段的数量等。
* 代码段(.text)：目标文件中，源代码编译后的机器指令经常被放在代码段里
* 数据段(.data)：目标文件中，源代码编译后的全局变量和局部静态变量数据经常放在数据段
* .bss段：目标文件中，源代码编译后的未初始化的全局变量和局部静态变量一般放在.bss段里
* 只读数据段(.rodata)：只读数据段存放的是只读数据，一般是程序里面的只读变量和字符串常量。有时候编译器会把字符串常量放到数据段(.data)
* ... 其他段
* 段表：段表是目标文件中除了文件头意外最重要的结构，他描述了目标文件各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限以及段的其他属性。目标文件的段结构就是由段表决定的，编译器、链接器和装载器都是依靠段表来定位和访问各个段的属性的。
* 字符串表：目标文件中用到了很多字符串，比如段名、变量名等，因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后用字符串在表中的偏移来引用字符串。
* 符号表：符号表的结构很简单，它是一个Elf32_Sym结构的数组，每个结构对应一个符号。
* 总体来说，程序源代码被编译以后主要分成两种段：程序指令与程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据。对于进程来说，指令区域是只读的，数据区域是可读写的。

## 汇编

汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。
