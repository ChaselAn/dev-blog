# 基础算法

## 链表与数组

### 性能对比

| 时间复杂度 | 数组 | 链表 |

| —— | —— | —— |

| 插入删除 |  O(n) | O(1) |

| 随机访问 | O(1) | O(n) |

###  基于链表实现LRU算法

* 维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。
* 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后在插入到链表的头部。
* 如果此数据没有在缓存链表中，如果此时缓存未满，则将此结点直接插入到链表头部，如果此时缓存已满，则链表尾结点删除，将新的数据节点插入链表的头部。
* 缓存访问的时间复杂度O(n)。
* 优化：引入散列表来记录每个数据的位置，将缓存访问的时间复杂度降到O(1)。

## 排序

### 冒泡排序

* 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，最多重复n次，完成排序。
* 时间复杂度：最好 O(n)  最坏 O(n^2)  平均 O(n^2) 
* 是否稳定： 是

### 插入排序

* 首先，将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组第一个元素。插入算法的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。
* 时间复杂度：最好 O(n)  最坏 O(n^2)  平均 O(n^2) 
* 是否稳定： 是

### 选择排序

* 选择排序也分已排序区间和未排序区间，但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。
* 时间复杂度：最好 O(n^2)  最坏 O(n^2)  平均 O(n^2) 
* 是否稳定： 否

### 归并排序

* 先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起。
* 时间复杂度： O(nlogn)  空间复杂度： O(n)   是否稳定： 是

### 快速排序

* 如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot (分区点)。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。然后用递归排序下标从 p 到 pivot下标-1 之间的数据和小标从 pivot下标+1 到 r 之间的数据，直到区间缩小为1。
* 时间复杂度： O(nlogn)  空间复杂度： O(1)  是否稳定： 否

## 二叉树

### 遍历

* 前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
* 中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
* 后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印本身。
* 时间复杂度： 都是O(n)

### 二叉查找树

* 二叉查找树要求，在树的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。
* 中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度O(n)
* 时间复杂度：平衡二叉查找树插入、删除、查找操作都是 O(logn)
* AVL树是平衡二叉查找树

### 红黑树

* 红黑树中的节点，一类被标记为黑色，一类被标记为红色。红黑树满足以下要求。
* 1. 根节点是黑色的
  2. 每个叶子节点都是黑色的空节点，也就是说，叶子节点不存储数据。
  3. 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的。
  4. 每个节点，从该节点到达可达叶子节点的所有路径，都包含相同数目的黑色节点。
* 红黑树是近似平衡的。平衡的意思可以等价为性能不退化，近似平衡就等价为性能不会退化的太严重。
* 时间复杂度：插入、删除、查找操作都是 O(logn)

## 堆

* 堆是一个完全二叉树，堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值。

- 时间复杂度： 插入、删除都是 O(logn)

### 堆排序

* 堆排序包括建堆和排序两个操作
* 建堆的过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是O(nlogn)

### 堆排序 vs 快排

* 堆排序数据访问的方式没有快排友好。快排数据是顺序访问，堆排序数据是跳着访问，对CPU缓存不友好。
* 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快排

# iOS相关

## 性能优化

### 卡顿解决的主要思路：

- 尽可能减少CPU、GPU资源消耗
- 按照60FPS的刷帧率，每隔16ms就会有一次VSync信号
- 尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用CALayer取代UIView
- 不要频繁地调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改
- 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性
- Autolayout会比直接设置frame消耗更多的CPU资源
- 图片的size最好刚好跟UIImageView的size保持一致
- 控制一下线程的最大并发数量
- 尽量把耗时的操作放到子线程
- 文本处理（尺寸计算、绘制）
- 图片处理（解码、绘制）
- 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示
- GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸
- 尽量减少视图数量和层次
- 减少透明的视图（alpha<1），不透明的就设置opaque为YES
- 尽量避免出现离屏渲染
- [iOS 保持界面流畅的技巧](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)

### 离屏渲染

在OpenGL中，GPU有2种渲染方式：

- On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作
- Off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作

离屏渲染消耗性能的原因

- 需要创建新的缓冲区
- 离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕

哪些操作会触发离屏渲染？

* 官方公开的的资料里关于离屏渲染的信息最早是在 2011年的 WWDC， 在多个 session 里都提到了尽量避免会触发离屏渲染的效果，包括：mask, shadow, group opacity, edge antialiasing。
* 光栅化，layer.shouldRasterize = YES
* 遮罩，layer.mask
* 圆角，同时设置layer.masksToBounds = YES、layer.cornerRadius大于0
* 考虑通过CoreGraphics绘制裁剪圆角，或者叫美工提供圆角图片
* 阴影，layer.shadowXXX
* 如果设置了layer.shadowPath就不会产生离屏渲染

### Swift特性方面优化

多用结构体，类中尽量用final修饰。结构体和final修饰的方法底层会使用直接派发的方式调用，效率极高，其他方法使用函数表派发方式调用，OC使用消息表派发方式调用。

[<http://www.starming.com/2018/01/24/why-swift/>](<http://www.starming.com/2018/01/24/why-swift/>)

## app启动

新建一个 Swift 的 iOS app 项目后，我们会发现所有文件中都没有一个像 Objective-C 时那样的 main 文件，也不存在 main 函数。唯一和 main 有关系的是在默认的 AppDelegate 类的声明上方有一个 @UIApplicationMain 的标签。不说可能您也已经猜到，这个标签做的事情就是将被标注的类作为委托，去创建一个 UIApplication 并启动整个程序。在编译的时候，编译器将寻找这个标记的类，并自动插入像 main 函数这样的模板代码。

# 设计模式

[面向对象六大原则](<https://www.cnblogs.com/qifengshi/p/5709594.html>)

* 单一职责原则——SRP
* 开闭原则——OCP
* 里式替换原则——LSP
* 依赖倒置原则——DIP
* 接口隔离原则——ISP
* 迪米特原则——LOD